package selinux

import (
	"fmt"
	"sort"
	"strings"

	"github.com/cici0602/pml-to-selinux/models"
)

// SemanageGenerator generates semanage commands for policy deployment
type SemanageGenerator struct {
	policy *models.SELinuxPolicy
}

// NewSemanageGenerator creates a new SemanageGenerator instance
func NewSemanageGenerator(policy *models.SELinuxPolicy) *SemanageGenerator {
	return &SemanageGenerator{
		policy: policy,
	}
}

// SemanageCommands contains all semanage commands for deployment
type SemanageCommands struct {
	BooleanCommands     []string
	FileContextCommands []string
	PortCommands        []string
	UserCommands        []string
	ModuleCommands      []string
}

// GenerateCommands generates all semanage commands needed for deployment
func (g *SemanageGenerator) GenerateCommands() *SemanageCommands {
	commands := &SemanageCommands{
		BooleanCommands:     make([]string, 0),
		FileContextCommands: make([]string, 0),
		PortCommands:        make([]string, 0),
		UserCommands:        make([]string, 0),
		ModuleCommands:      make([]string, 0),
	}

	// Generate file context commands
	commands.FileContextCommands = g.generateFileContextCommands()

	// Generate module installation commands
	commands.ModuleCommands = g.generateModuleCommands()

	return commands
}

// generateFileContextCommands generates semanage fcontext commands
func (g *SemanageGenerator) generateFileContextCommands() []string {
	commands := make([]string, 0)

	if len(g.policy.FileContexts) == 0 {
		return commands
	}

	// Sort file contexts for consistent output
	contexts := make([]models.FileContext, len(g.policy.FileContexts))
	copy(contexts, g.policy.FileContexts)
	sort.Slice(contexts, func(i, j int) bool {
		return contexts[i].PathPattern < contexts[j].PathPattern
	})

	for _, fc := range contexts {
		// Determine file type flag
		fileTypeFlag := ""
		switch fc.FileType {
		case "dir":
			fileTypeFlag = "-d"
		case "file":
			fileTypeFlag = "-f"
		case "socket":
			fileTypeFlag = "-s"
		case "pipe":
			fileTypeFlag = "-p"
		case "symlink":
			fileTypeFlag = "-l"
		case "block":
			fileTypeFlag = "-b"
		case "char":
			fileTypeFlag = "-c"
		default:
			fileTypeFlag = "-a" // all files
		}

		// Add file context
		// Use SELinuxType instead of Context
		cmd := fmt.Sprintf("semanage fcontext -a -t %s %s '%s'",
			fc.SELinuxType, fileTypeFlag, fc.PathPattern)
		commands = append(commands, cmd)
	}
	// Add restorecon command to apply changes
	if len(commands) > 0 {
		commands = append(commands, "")
		commands = append(commands, "# Apply file contexts")
		commands = append(commands, "restorecon -Rv /")
	}

	return commands
}

// generateModuleCommands generates module installation commands
func (g *SemanageGenerator) generateModuleCommands() []string {
	commands := make([]string, 0)

	moduleName := g.policy.ModuleName

	// Commands to compile and install the module
	commands = append(commands, "# Compile the policy module")
	commands = append(commands, fmt.Sprintf("checkmodule -M -m -o %s.mod %s.te", moduleName, moduleName))
	commands = append(commands, "")

	commands = append(commands, "# Package the module")
	commands = append(commands, fmt.Sprintf("semodule_package -o %s.pp -m %s.mod -fc %s.fc", moduleName, moduleName, moduleName))
	commands = append(commands, "")

	commands = append(commands, "# Install the module")
	commands = append(commands, fmt.Sprintf("semodule -i %s.pp", moduleName))
	commands = append(commands, "")

	commands = append(commands, "# Verify installation")
	commands = append(commands, fmt.Sprintf("semodule -l | grep %s", moduleName))
	commands = append(commands, "")

	// Add removal command as comment
	commands = append(commands, "# To remove the module:")
	commands = append(commands, fmt.Sprintf("# semodule -r %s", moduleName))

	return commands
}

// GeneratePortCommand generates a semanage port command
func GeneratePortCommand(port int, protocol, portType string) string {
	return fmt.Sprintf("semanage port -a -t %s -p %s %d", portType, protocol, port)
}

// GenerateUserCommand generates a semanage user command
func GenerateUserCommand(username, roles string) string {
	return fmt.Sprintf("semanage user -a -R \"%s\" %s", roles, username)
}

// GenerateDeploymentScript generates a complete deployment script
func (g *SemanageGenerator) GenerateDeploymentScript() string {
	var builder strings.Builder

	builder.WriteString("#!/bin/bash\n")
	builder.WriteString("########################################\n")
	builder.WriteString(fmt.Sprintf("# SELinux Deployment Script for %s\n", g.policy.ModuleName))
	builder.WriteString("# Generated by PML-to-SELinux Compiler\n")
	builder.WriteString("########################################\n\n")

	builder.WriteString("set -e  # Exit on error\n\n")

	builder.WriteString(fmt.Sprintf("echo \"Deploying SELinux policy: %s\"\n\n", g.policy.ModuleName))

	commands := g.GenerateCommands()

	// Module installation
	if len(commands.ModuleCommands) > 0 {
		builder.WriteString("########################################\n")
		builder.WriteString("# Module Installation\n")
		builder.WriteString("########################################\n\n")

		for _, cmd := range commands.ModuleCommands {
			builder.WriteString(cmd)
			builder.WriteString("\n")
		}
		builder.WriteString("\n")
	}

	// Boolean configuration
	if len(commands.BooleanCommands) > 0 {
		builder.WriteString("########################################\n")
		builder.WriteString("# Boolean Configuration\n")
		builder.WriteString("########################################\n\n")

		for _, cmd := range commands.BooleanCommands {
			builder.WriteString(cmd)
			builder.WriteString("\n")
		}
		builder.WriteString("\n")
	}

	// File context configuration
	if len(commands.FileContextCommands) > 0 {
		builder.WriteString("########################################\n")
		builder.WriteString("# File Context Configuration\n")
		builder.WriteString("########################################\n\n")

		for _, cmd := range commands.FileContextCommands {
			builder.WriteString(cmd)
			builder.WriteString("\n")
		}
		builder.WriteString("\n")
	}

	builder.WriteString("echo \"Deployment completed successfully!\"\n")

	return builder.String()
}

// GenerateUninstallScript generates a script to uninstall the policy
func (g *SemanageGenerator) GenerateUninstallScript() string {
	var builder strings.Builder

	builder.WriteString("#!/bin/bash\n")
	builder.WriteString("########################################\n")
	builder.WriteString(fmt.Sprintf("# SELinux Uninstall Script for %s\n", g.policy.ModuleName))
	builder.WriteString("# Generated by PML-to-SELinux Compiler\n")
	builder.WriteString("########################################\n\n")

	builder.WriteString("set -e  # Exit on error\n\n")

	builder.WriteString(fmt.Sprintf("echo \"Uninstalling SELinux policy: %s\"\n\n", g.policy.ModuleName))

	// Remove module
	builder.WriteString("# Remove policy module\n")
	builder.WriteString(fmt.Sprintf("semodule -r %s\n\n", g.policy.ModuleName))

	// Remove file contexts
	if len(g.policy.FileContexts) > 0 {
		builder.WriteString("# Remove file contexts\n")

		contexts := make([]models.FileContext, len(g.policy.FileContexts))
		copy(contexts, g.policy.FileContexts)
		sort.Slice(contexts, func(i, j int) bool {
			return contexts[i].PathPattern < contexts[j].PathPattern
		})

		for _, fc := range contexts {
			builder.WriteString(fmt.Sprintf("semanage fcontext -d '%s'\n", fc.PathPattern))
		}
		builder.WriteString("\n")
	}

	builder.WriteString("echo \"Uninstallation completed successfully!\"\n")

	return builder.String()
}

// GenerateSemanageCommands is a convenience function to generate semanage commands
func GenerateSemanageCommands(policy *models.SELinuxPolicy) *SemanageCommands {
	generator := NewSemanageGenerator(policy)
	return generator.GenerateCommands()
}

// GenerateDeployScript is a convenience function to generate deployment script
func GenerateDeployScript(policy *models.SELinuxPolicy) string {
	generator := NewSemanageGenerator(policy)
	return generator.GenerateDeploymentScript()
}
