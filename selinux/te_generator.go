package selinux

import (
	"fmt"
	"sort"
	"strings"

	"github.com/cici0602/pml-to-selinux/models"
)

// TEGenerator handles generation of SELinux Type Enforcement (.te) files
type TEGenerator struct {
	policy *models.SELinuxPolicy
}

// NewTEGenerator creates a new TEGenerator instance
func NewTEGenerator(policy *models.SELinuxPolicy) *TEGenerator {
	return &TEGenerator{
		policy: policy,
	}
}

// Generate generates the complete .te file content
func (g *TEGenerator) Generate() (string, error) {
	var builder strings.Builder

	// Write header
	g.writeHeader(&builder)

	// Write policy module declaration
	g.writePolicyModule(&builder)

	// Write type declarations
	if err := g.writeTypeDeclarations(&builder); err != nil {
		return "", err
	}

	// Write allow rules
	if err := g.writeAllowRules(&builder); err != nil {
		return "", err
	}

	// Write deny rules (neverallow)
	if err := g.writeDenyRules(&builder); err != nil {
		return "", err
	}

	// Write type transitions if any
	if err := g.writeTypeTransitions(&builder); err != nil {
		return "", err
	}

	return builder.String(), nil
}

// writeHeader writes the file header with comments
func (g *TEGenerator) writeHeader(builder *strings.Builder) {
	builder.WriteString("########################################\n")
	builder.WriteString(fmt.Sprintf("# SELinux Policy Module: %s\n", g.policy.ModuleName))
	builder.WriteString(fmt.Sprintf("# Version: %s\n", g.policy.Version))
	builder.WriteString("# Generated by PML-to-SELinux Compiler\n")
	builder.WriteString("########################################\n\n")
}

// writePolicyModule writes the policy_module declaration
func (g *TEGenerator) writePolicyModule(builder *strings.Builder) {
	builder.WriteString(fmt.Sprintf("policy_module(%s, %s)\n\n",
		g.policy.ModuleName,
		g.policy.Version))
}

// writeTypeDeclarations writes all type declarations
func (g *TEGenerator) writeTypeDeclarations(builder *strings.Builder) error {
	if len(g.policy.Types) == 0 {
		return nil
	}

	builder.WriteString("########################################\n")
	builder.WriteString("# Type Declarations\n")
	builder.WriteString("########################################\n\n")

	// Sort types for consistent output
	types := make([]models.TypeDeclaration, len(g.policy.Types))
	copy(types, g.policy.Types)
	sort.Slice(types, func(i, j int) bool {
		return types[i].TypeName < types[j].TypeName
	})

	for _, typeDecl := range types {
		if len(typeDecl.Attributes) > 0 {
			// Type with attributes: type typename, attr1, attr2;
			builder.WriteString(fmt.Sprintf("type %s, %s;\n",
				typeDecl.TypeName,
				strings.Join(typeDecl.Attributes, ", ")))
		} else {
			// Simple type declaration: type typename;
			builder.WriteString(fmt.Sprintf("type %s;\n", typeDecl.TypeName))
		}
	}

	builder.WriteString("\n")
	return nil
}

// writeAllowRules writes all allow rules, grouped by source type
func (g *TEGenerator) writeAllowRules(builder *strings.Builder) error {
	if len(g.policy.Rules) == 0 {
		return nil
	}

	builder.WriteString("########################################\n")
	builder.WriteString("# Allow Rules\n")
	builder.WriteString("########################################\n\n")

	// Group rules by source type, target type, and class
	ruleGroups := g.groupRules(g.policy.Rules)

	// Sort source types for consistent output
	sourceTypes := make([]string, 0, len(ruleGroups))
	for sourceType := range ruleGroups {
		sourceTypes = append(sourceTypes, sourceType)
	}
	sort.Strings(sourceTypes)

	// Write rules for each source type
	for _, sourceType := range sourceTypes {
		builder.WriteString(fmt.Sprintf("# Rules for %s\n", sourceType))

		targets := ruleGroups[sourceType]
		targetKeys := make([]string, 0, len(targets))
		for key := range targets {
			targetKeys = append(targetKeys, key)
		}
		sort.Strings(targetKeys)

		for _, targetKey := range targetKeys {
			perms := targets[targetKey]
			parts := strings.Split(targetKey, ":")
			targetType := parts[0]
			class := parts[1]

			// Sort permissions
			sort.Strings(perms)

			// Write allow rule
			if len(perms) == 1 {
				builder.WriteString(fmt.Sprintf("allow %s %s:%s %s;\n",
					sourceType, targetType, class, perms[0]))
			} else {
				builder.WriteString(fmt.Sprintf("allow %s %s:%s { %s };\n",
					sourceType, targetType, class, strings.Join(perms, " ")))
			}
		}

		builder.WriteString("\n")
	}

	return nil
}

// groupRules groups allow rules by source, target, and class to merge permissions
func (g *TEGenerator) groupRules(rules []models.AllowRule) map[string]map[string][]string {
	// Map: sourceType -> "targetType:class" -> []permissions
	groups := make(map[string]map[string][]string)

	for _, rule := range rules {
		if _, ok := groups[rule.SourceType]; !ok {
			groups[rule.SourceType] = make(map[string][]string)
		}

		key := rule.TargetType + ":" + rule.Class
		groups[rule.SourceType][key] = append(groups[rule.SourceType][key], rule.Permissions...)
	}

	// Deduplicate permissions
	for sourceType := range groups {
		for targetKey := range groups[sourceType] {
			groups[sourceType][targetKey] = uniqueStrings(groups[sourceType][targetKey])
		}
	}

	return groups
}

// writeDenyRules writes all deny rules (as neverallow)
func (g *TEGenerator) writeDenyRules(builder *strings.Builder) error {
	if len(g.policy.DenyRules) == 0 {
		return nil
	}

	builder.WriteString("########################################\n")
	builder.WriteString("# Deny Rules (neverallow)\n")
	builder.WriteString("########################################\n\n")

	// Sort deny rules for consistent output
	denyRules := make([]models.DenyRule, len(g.policy.DenyRules))
	copy(denyRules, g.policy.DenyRules)
	sort.Slice(denyRules, func(i, j int) bool {
		if denyRules[i].SourceType != denyRules[j].SourceType {
			return denyRules[i].SourceType < denyRules[j].SourceType
		}
		if denyRules[i].TargetType != denyRules[j].TargetType {
			return denyRules[i].TargetType < denyRules[j].TargetType
		}
		return denyRules[i].Class < denyRules[j].Class
	})

	for _, rule := range denyRules {
		// Sort permissions
		perms := make([]string, len(rule.Permissions))
		copy(perms, rule.Permissions)
		sort.Strings(perms)

		if len(perms) == 1 {
			builder.WriteString(fmt.Sprintf("neverallow %s %s:%s %s;\n",
				rule.SourceType, rule.TargetType, rule.Class, perms[0]))
		} else {
			builder.WriteString(fmt.Sprintf("neverallow %s %s:%s { %s };\n",
				rule.SourceType, rule.TargetType, rule.Class, strings.Join(perms, " ")))
		}
	}

	builder.WriteString("\n")
	return nil
}

// writeTypeTransitions writes type transition rules if any
func (g *TEGenerator) writeTypeTransitions(builder *strings.Builder) error {
	if len(g.policy.Transitions) == 0 {
		return nil
	}

	builder.WriteString("########################################\n")
	builder.WriteString("# Type Transitions\n")
	builder.WriteString("########################################\n\n")

	// Sort transitions for consistent output
	transitions := make([]models.TypeTransition, len(g.policy.Transitions))
	copy(transitions, g.policy.Transitions)
	sort.Slice(transitions, func(i, j int) bool {
		if transitions[i].SourceType != transitions[j].SourceType {
			return transitions[i].SourceType < transitions[j].SourceType
		}
		if transitions[i].TargetType != transitions[j].TargetType {
			return transitions[i].TargetType < transitions[j].TargetType
		}
		return transitions[i].Class < transitions[j].Class
	})

	for _, trans := range transitions {
		builder.WriteString(fmt.Sprintf("type_transition %s %s:%s %s;\n",
			trans.SourceType, trans.TargetType, trans.Class, trans.NewType))
	}

	builder.WriteString("\n")
	return nil
}

// uniqueStrings removes duplicates from a string slice
func uniqueStrings(slice []string) []string {
	seen := make(map[string]bool)
	result := make([]string, 0, len(slice))

	for _, item := range slice {
		if !seen[item] {
			seen[item] = true
			result = append(result, item)
		}
	}

	return result
}

// GenerateTE is a convenience function to generate .te file content
func GenerateTE(policy *models.SELinuxPolicy) (string, error) {
	generator := NewTEGenerator(policy)
	return generator.Generate()
}
