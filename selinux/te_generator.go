// Copyright 2025 The casbin Authors. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package selinux

import (
	"fmt"
	"sort"
	"strings"

	"github.com/cici0602/pml-to-selinux/models"
)

// TEGenerator handles generation of SELinux Type Enforcement (.te) files
type TEGenerator struct {
	policy *models.SELinuxPolicy
}

// NewTEGenerator creates a new TEGenerator instance
func NewTEGenerator(policy *models.SELinuxPolicy) *TEGenerator {
	return &TEGenerator{
		policy: policy,
	}
}

// Generate generates the complete .te file content
func (g *TEGenerator) Generate() (string, error) {
	var builder strings.Builder

	// Write header
	g.writeHeader(&builder)

	// Write policy module declaration
	g.writePolicyModule(&builder)

	// Write type declarations
	if err := g.writeTypeDeclarations(&builder); err != nil {
		return "", err
	}

	// Write allow rules
	if err := g.writeAllowRules(&builder); err != nil {
		return "", err
	}

	// Write deny rules (neverallow)
	if err := g.writeDenyRules(&builder); err != nil {
		return "", err
	}

	// Write type transitions if any
	if err := g.writeTypeTransitions(&builder); err != nil {
		return "", err
	}

	return builder.String(), nil
}

// writeHeader writes the file header with comments
func (g *TEGenerator) writeHeader(builder *strings.Builder) {
	builder.WriteString("########################################\n")
	builder.WriteString(fmt.Sprintf("# SELinux Policy Module: %s\n", g.policy.ModuleName))
	builder.WriteString(fmt.Sprintf("# Version: %s\n", g.policy.Version))
	builder.WriteString("# Generated by PML-to-SELinux Compiler\n")
	builder.WriteString("########################################\n\n")
}

// writePolicyModule writes the policy_module declaration
func (g *TEGenerator) writePolicyModule(builder *strings.Builder) {
	builder.WriteString(fmt.Sprintf("policy_module(%s, %s)\n\n",
		g.policy.ModuleName,
		g.policy.Version))
}

// writeTypeDeclarations writes all type declarations
func (g *TEGenerator) writeTypeDeclarations(builder *strings.Builder) error {
	if len(g.policy.Types) == 0 {
		return nil
	}

	builder.WriteString("########################################\n")
	builder.WriteString("# Type Declarations\n")
	builder.WriteString("########################################\n\n")

	// Sort types for consistent output
	types := make([]models.TypeDeclaration, len(g.policy.Types))
	copy(types, g.policy.Types)
	sort.Slice(types, func(i, j int) bool {
		return types[i].TypeName < types[j].TypeName
	})

	for _, typeDecl := range types {
		if len(typeDecl.Attributes) > 0 {
			// Type with attributes: type typename, attr1, attr2;
			builder.WriteString(fmt.Sprintf("type %s, %s;\n",
				typeDecl.TypeName,
				strings.Join(typeDecl.Attributes, ", ")))
		} else {
			// Simple type declaration: type typename;
			builder.WriteString(fmt.Sprintf("type %s;\n", typeDecl.TypeName))
		}
	}

	builder.WriteString("\n")
	return nil
}

// writeAllowRules writes all allow rules, grouped by source type
func (g *TEGenerator) writeAllowRules(builder *strings.Builder) error {
	if len(g.policy.Rules) == 0 {
		return nil
	}

	builder.WriteString("########################################\n")
	builder.WriteString("# Allow Rules\n")
	builder.WriteString("########################################\n\n")

	// Group rules by source type, target type, and class
	ruleGroups := g.groupRules(g.policy.Rules)

	// Sort source types for consistent output
	sourceTypes := make([]string, 0, len(ruleGroups))
	for sourceType := range ruleGroups {
		sourceTypes = append(sourceTypes, sourceType)
	}
	sort.Strings(sourceTypes)

	// Write rules for each source type
	for _, sourceType := range sourceTypes {
		builder.WriteString(fmt.Sprintf("# Rules for %s\n", sourceType))

		targets := ruleGroups[sourceType]
		targetKeys := make([]string, 0, len(targets))
		for key := range targets {
			targetKeys = append(targetKeys, key)
		}
		sort.Strings(targetKeys)

		for _, targetKey := range targetKeys {
			perms := targets[targetKey]
			parts := strings.Split(targetKey, ":")
			targetType := parts[0]
			class := parts[1]

			// Sort permissions
			sort.Strings(perms)

			// Write allow rule
			if len(perms) == 1 {
				builder.WriteString(fmt.Sprintf("allow %s %s:%s %s;\n",
					sourceType, targetType, class, perms[0]))
			} else {
				builder.WriteString(fmt.Sprintf("allow %s %s:%s { %s };\n",
					sourceType, targetType, class, strings.Join(perms, " ")))
			}
		}

		builder.WriteString("\n")
	}

	return nil
}

// groupRules groups allow rules by source, target, and class to merge permissions
func (g *TEGenerator) groupRules(rules []models.AllowRule) map[string]map[string][]string {
	// Map: sourceType -> "targetType:class" -> []permissions
	groups := make(map[string]map[string][]string)

	for _, rule := range rules {
		if _, ok := groups[rule.SourceType]; !ok {
			groups[rule.SourceType] = make(map[string][]string)
		}

		key := rule.TargetType + ":" + rule.Class
		groups[rule.SourceType][key] = append(groups[rule.SourceType][key], rule.Permissions...)
	}

	// Deduplicate permissions
	for sourceType := range groups {
		for targetKey := range groups[sourceType] {
			groups[sourceType][targetKey] = uniqueStrings(groups[sourceType][targetKey])
		}
	}

	return groups
}

// writeDenyRules - Deny rules not supported in simplified version
func (g *TEGenerator) writeDenyRules(builder *strings.Builder) error {
	// Deny rules removed in simplified version
	// For production use, consider using audit_deny or neverallow manually
	return nil
}

// writeTypeTransitions writes type transition rules if any
func (g *TEGenerator) writeTypeTransitions(builder *strings.Builder) error {
	if len(g.policy.Transitions) == 0 {
		return nil
	}

	builder.WriteString("########################################\n")
	builder.WriteString("# Type Transitions\n")
	builder.WriteString("########################################\n\n")

	// Sort transitions for consistent output
	transitions := make([]models.TypeTransition, len(g.policy.Transitions))
	copy(transitions, g.policy.Transitions)
	sort.Slice(transitions, func(i, j int) bool {
		if transitions[i].SourceType != transitions[j].SourceType {
			return transitions[i].SourceType < transitions[j].SourceType
		}
		if transitions[i].TargetType != transitions[j].TargetType {
			return transitions[i].TargetType < transitions[j].TargetType
		}
		return transitions[i].Class < transitions[j].Class
	})

	// Generate domain transitions with supporting rules
	for _, trans := range transitions {
		if trans.Class == "process" {
			// This is a domain transition, generate the complete triplet
			g.writeDomainTransitionRules(builder, &trans)
		} else {
			// Regular type transition
			builder.WriteString(fmt.Sprintf("type_transition %s %s:%s %s;\n",
				trans.SourceType, trans.TargetType, trans.Class, trans.NewType))
		}
	}

	builder.WriteString("\n")
	return nil
}

// writeDomainTransitionRules generates the complete domain transition triplet:
// 1. type_transition - defines the transition
// 2. allow source target:file execute - parent can execute child binary
// 3. allow source target:process transition - parent can transition to child
// 4. allow target target:file entrypoint - child can use its binary as entrypoint
func (g *TEGenerator) writeDomainTransitionRules(builder *strings.Builder, trans *models.TypeTransition) {
	source := trans.SourceType
	entrypoint := trans.TargetType
	target := trans.NewType

	builder.WriteString(fmt.Sprintf("# Domain transition: %s -> %s\n", source, target))

	// 1. Type transition rule
	builder.WriteString(fmt.Sprintf("type_transition %s %s:process %s;\n",
		source, entrypoint, target))

	// 2. Allow parent to execute child binary
	builder.WriteString(fmt.Sprintf("allow %s %s:file execute;\n",
		source, entrypoint))

	// 3. Allow parent to transition to child domain
	builder.WriteString(fmt.Sprintf("allow %s %s:process transition;\n",
		source, target))

	// 4. Allow child to use binary as entrypoint
	builder.WriteString(fmt.Sprintf("allow %s %s:file entrypoint;\n",
		target, entrypoint))

	builder.WriteString("\n")
}

// uniqueStrings removes duplicates from a string slice
func uniqueStrings(slice []string) []string {
	seen := make(map[string]bool)
	result := make([]string, 0, len(slice))

	for _, item := range slice {
		if !seen[item] {
			seen[item] = true
			result = append(result, item)
		}
	}

	return result
}

// GenerateTE is a convenience function to generate .te file content
func GenerateTE(policy *models.SELinuxPolicy) (string, error) {
	generator := NewTEGenerator(policy)
	return generator.Generate()
}
