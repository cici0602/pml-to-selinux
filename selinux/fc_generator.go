package selinux

import (
	"fmt"
	"sort"
	"strings"

	"github.com/cici0602/pml-to-selinux/mapping"
	"github.com/cici0602/pml-to-selinux/models"
)

// FCGenerator handles generation of SELinux File Context (.fc) files
type FCGenerator struct {
	policy *models.SELinuxPolicy
}

// NewFCGenerator creates a new FCGenerator instance
func NewFCGenerator(policy *models.SELinuxPolicy) *FCGenerator {
	return &FCGenerator{
		policy: policy,
	}
}

// Generate generates the complete .fc file content
func (g *FCGenerator) Generate() (string, error) {
	var builder strings.Builder

	// Write header
	g.writeHeader(&builder)

	// Write file contexts
	if err := g.writeFileContexts(&builder); err != nil {
		return "", err
	}

	return builder.String(), nil
}

// writeHeader writes the file header with comments
func (g *FCGenerator) writeHeader(builder *strings.Builder) {
	builder.WriteString("########################################\n")
	builder.WriteString(fmt.Sprintf("# SELinux File Contexts: %s\n", g.policy.ModuleName))
	builder.WriteString(fmt.Sprintf("# Version: %s\n", g.policy.Version))
	builder.WriteString("# Generated by PML-to-SELinux Compiler\n")
	builder.WriteString("########################################\n\n")
}

// writeFileContexts writes all file context specifications
func (g *FCGenerator) writeFileContexts(builder *strings.Builder) error {
	if len(g.policy.FileContexts) == 0 {
		return nil
	}

	// Sort file contexts by path pattern for consistent output
	contexts := make([]models.FileContext, len(g.policy.FileContexts))
	copy(contexts, g.policy.FileContexts)
	sort.Slice(contexts, func(i, j int) bool {
		return contexts[i].PathPattern < contexts[j].PathPattern
	})

	// Group contexts by directory for better organization
	contextsByDir := g.groupContextsByDirectory(contexts)

	// Get sorted directory names
	dirs := make([]string, 0, len(contextsByDir))
	for dir := range contextsByDir {
		dirs = append(dirs, dir)
	}
	sort.Strings(dirs)

	// Write contexts for each directory
	for i, dir := range dirs {
		if i > 0 {
			builder.WriteString("\n")
		}

		if dir != "/" {
			builder.WriteString(fmt.Sprintf("# Contexts for %s\n", dir))
		}

		for _, fc := range contextsByDir[dir] {
			if err := g.writeFileContext(builder, fc); err != nil {
				return err
			}
		}
	}

	return nil
}

// writeFileContext writes a single file context specification
func (g *FCGenerator) writeFileContext(builder *strings.Builder, fc models.FileContext) error {
	// Get file type specifier
	fileTypeSpec := mapping.GetFileTypeSpecifier(fc.FileType)

	// Build the context string if not already set
	context := fc.Context
	if context == "" {
		context = fmt.Sprintf("%s:%s:%s:%s",
			fc.User, fc.Role, fc.FileType, fc.Level)
	}

	// Use gen_context for proper format
	// Format: /path/pattern file_type_spec gen_context(system_u:object_r:type_t:s0)
	builder.WriteString(fmt.Sprintf("%s%s\tgen_context(%s)\n",
		fc.PathPattern,
		fileTypeSpec,
		context))

	return nil
}

// groupContextsByDirectory groups file contexts by their base directory
func (g *FCGenerator) groupContextsByDirectory(contexts []models.FileContext) map[string][]models.FileContext {
	groups := make(map[string][]models.FileContext)

	for _, fc := range contexts {
		// Extract base directory from path pattern
		baseDir := extractBaseDirectory(fc.PathPattern)
		groups[baseDir] = append(groups[baseDir], fc)
	}

	return groups
}

// extractBaseDirectory extracts the base directory from a path pattern
func extractBaseDirectory(pattern string) string {
	// Remove regex patterns
	pattern = strings.TrimSuffix(pattern, "(/.*)?")
	pattern = strings.TrimSuffix(pattern, "(.*)")

	// Find the last directory separator
	lastSlash := strings.LastIndex(pattern, "/")
	if lastSlash <= 0 {
		return "/"
	}

	return pattern[:lastSlash]
}

// GenerateFC is a convenience function to generate .fc file content
func GenerateFC(policy *models.SELinuxPolicy) (string, error) {
	generator := NewFCGenerator(policy)
	return generator.Generate()
}

// WriteFiles writes both .te and .fc files to the specified directory
func WriteFiles(outputDir string, policy *models.SELinuxPolicy) error {
	// This will be implemented to actually write files to disk
	// For now, just validate the policy
	if policy == nil {
		return fmt.Errorf("policy cannot be nil")
	}

	if policy.ModuleName == "" {
		return fmt.Errorf("policy module name cannot be empty")
	}

	// TODO: Implement actual file writing
	return nil
}
