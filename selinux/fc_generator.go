package selinux

import (
	"fmt"
	"sort"
	"strings"

	"github.com/cici0602/pml-to-selinux/models"
)

// FCGenerator handles generation of SELinux File Context (.fc) files
type FCGenerator struct {
	policy *models.SELinuxPolicy
}

// NewFCGenerator creates a new FCGenerator instance
func NewFCGenerator(policy *models.SELinuxPolicy) *FCGenerator {
	return &FCGenerator{
		policy: policy,
	}
}

// Generate generates the complete .fc file content
func (g *FCGenerator) Generate() (string, error) {
	var builder strings.Builder

	// Write header
	g.writeHeader(&builder)

	// Write file contexts
	if err := g.writeFileContexts(&builder); err != nil {
		return "", err
	}

	return builder.String(), nil
}

// writeHeader writes the file header with comments
func (g *FCGenerator) writeHeader(builder *strings.Builder) {
	builder.WriteString("########################################\n")
	builder.WriteString(fmt.Sprintf("# SELinux File Contexts: %s\n", g.policy.ModuleName))
	builder.WriteString(fmt.Sprintf("# Version: %s\n", g.policy.Version))
	builder.WriteString("# Generated by PML-to-SELinux Compiler\n")
	builder.WriteString("########################################\n\n")
}

// writeFileContexts writes all file context specifications
func (g *FCGenerator) writeFileContexts(builder *strings.Builder) error {
	if len(g.policy.FileContexts) == 0 {
		return nil
	}

	// Sort file contexts by path pattern for consistent output
	contexts := make([]models.FileContext, len(g.policy.FileContexts))
	copy(contexts, g.policy.FileContexts)
	sort.Slice(contexts, func(i, j int) bool {
		return contexts[i].PathPattern < contexts[j].PathPattern
	})

	// Group contexts by directory for better organization
	contextsByDir := g.groupContextsByDirectory(contexts)

	// Get sorted directory names
	dirs := make([]string, 0, len(contextsByDir))
	for dir := range contextsByDir {
		dirs = append(dirs, dir)
	}
	sort.Strings(dirs)

	// Write contexts for each directory
	for i, dir := range dirs {
		if i > 0 {
			builder.WriteString("\n")
		}

		if dir != "/" {
			builder.WriteString(fmt.Sprintf("# Contexts for %s\n", dir))
		}

		for _, fc := range contextsByDir[dir] {
			if err := g.writeFileContext(builder, fc); err != nil {
				return err
			}
		}
	}

	return nil
}

// writeFileContext writes a single file context specification
func (g *FCGenerator) writeFileContext(builder *strings.Builder, fc models.FileContext) error {
	// Get file type specifier (e.g., "--" for file, "-d" for directory, "" for all types)
	fileTypeSpec := fc.FileType
	if fileTypeSpec == "" {
		// Empty file type means match all file types - no specifier needed
		fileTypeSpec = ""
	}

	// Build the full SELinux context: system_u:object_r:type_t:s0
	context := fmt.Sprintf("system_u:object_r:%s:s0", fc.SELinuxType)

	// Format with or without file type specifier
	if fileTypeSpec == "" {
		builder.WriteString(fmt.Sprintf("%s\tgen_context(%s)\n",
			fc.PathPattern,
			context))
	} else {
		builder.WriteString(fmt.Sprintf("%s\t%s\tgen_context(%s)\n",
			fc.PathPattern,
			fileTypeSpec,
			context))
	}

	return nil
}

// groupContextsByDirectory groups file contexts by their base directory
func (g *FCGenerator) groupContextsByDirectory(contexts []models.FileContext) map[string][]models.FileContext {
	groups := make(map[string][]models.FileContext)

	for _, fc := range contexts {
		// Extract base directory from path pattern
		baseDir := extractBaseDirectory(fc.PathPattern)
		groups[baseDir] = append(groups[baseDir], fc)
	}

	return groups
}

// extractBaseDirectory extracts the base directory from a path pattern
func extractBaseDirectory(pattern string) string {
	// Remove regex patterns
	pattern = strings.TrimSuffix(pattern, "(/.*)?")
	pattern = strings.TrimSuffix(pattern, "(.*)")

	// Find the last directory separator
	lastSlash := strings.LastIndex(pattern, "/")
	if lastSlash <= 0 {
		return "/"
	}

	return pattern[:lastSlash]
}

// GenerateFC is a convenience function to generate .fc file content
func GenerateFC(policy *models.SELinuxPolicy) (string, error) {
	generator := NewFCGenerator(policy)
	return generator.Generate()
}

// Note: File writing is handled by the CLI command directly
// using the individual generators (TEGenerator, FCGenerator, IFGenerator)
